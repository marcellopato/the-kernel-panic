<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE KERNEL PANIC</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            background-color: #000;
            color: #33ff00;
            font-family: 'VT323', monospace;
            font-size: 24px;
            margin: 0;
            padding: 20px;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            width: 100vw; /* Garante largura fixa */
        }

        * { box-sizing: border-box; }

        /* CRT Effect Overlay */
        .crt::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        #terminal {
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            padding-bottom: 20px;
            text-shadow: 0 0 5px #33ff00;
        }

        .input-line {
            display: flex;
            margin-top: 10px;
        }

        .prompt {
            color: #33ff00;
            margin-right: 10px;
            text-shadow: 0 0 5px #33ff00;
        }

        #cmd-input {
            background: transparent;
            border: none;
            color: #33ff00;
            font-family: 'VT323', monospace;
            font-size: 24px;
            flex-grow: 1;
            outline: none;
            text-shadow: 0 0 5px #33ff00;
        }

        .glitch {
            animation: glitch 1s linear infinite;
            display: inline-block; /* Cont√©m a transforma√ß√£o */
        }

        @keyframes glitch {
            2%, 64% { transform: translate(2px,0) skew(0deg); }
            4%, 60% { transform: translate(-2px,0) skew(0deg); }
            62% { transform: translate(0,0) skew(5deg); }
        }

        .ascii-art {
            font-size: 14px;
            line-height: 14px;
            color: #ff0000;
            margin-bottom: 20px;
        }

        .btn-hack {
            background: #33ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-family: 'VT323', monospace;
            font-size: 20px;
            cursor: pointer;
            margin-top: 10px;
            text-decoration: none;
            display: inline-block;
        }
        .btn-hack:hover {
            background: #fff;
        }
    </style>
</head>
<body class="crt">
    <div id="terminal"></div>
    <div class="input-line" id="input-area">
        <span class="prompt">guest@void:~$</span>
        <input type="text" id="cmd-input" autofocus autocomplete="off">
    </div>

    <script>
        const terminal = document.getElementById('terminal');
        const input = document.getElementById('cmd-input');
        const inputArea = document.getElementById('input-area');
        
        // --- ENGINE & UTILS ---
        const print = (text, className = '', speed = 10) => {
            const div = document.createElement('div');
            div.className = className;
            // Process basic formatting *bold* -> <b>bold</b>
            text = text.replace(/\*(.*?)\*/g, '<b>$1</b>');
            terminal.appendChild(div);
            
            let i = 0;
            // Instant print for faster gameplay feeling, or slow for atmosphere
            if (speed === 0) {
                div.innerHTML = text;
                terminal.scrollTop = terminal.scrollHeight;
                return;
            }
            
            const timer = setInterval(() => {
                // Simple char print logic - for full HTML support in typewriter would need complex parser
                // For now, we dump the finalized HTML at end of typing or type plain text
                if (text.includes('<')) { 
                    div.innerHTML = text; // Dump HTML immediately if present to avoid breaking tags
                    clearInterval(timer);
                } else {
                    div.textContent += text.charAt(i);
                    i++;
                    if (i >= text.length) clearInterval(timer);
                }
                terminal.scrollTop = terminal.scrollHeight;
            }, speed);
        };

        const printHTML = (html) => {
            const div = document.createElement('div');
            div.innerHTML = html;
            terminal.appendChild(div);
            terminal.scrollTop = terminal.scrollHeight;
        }

        const rng = (array) => array[Math.floor(Math.random() * array.length)];
        const chance = (percentage) => Math.random() * 100 < percentage;

        // --- ASSETS & DATA ---
        const worldData = {
            adjectives: ['Corrompido', 'Congelado', 'Escuro', 'Vibrante', 'Silencioso', 'Inundado', 'Radioativo', 'Antigo'],
            nouns: ['Mainframe', 'Setor de Dados', 'Corredor de Cabos', 'Laborat√≥rio', 'Sala de Backups', 'T√∫nel de Resfriamento'],
            details: ['cheira a oz√¥nio queimado.', 'tem cabos pulsando como veias.', 'est√° coberto de poeira cinza.', 'tem telas piscando olhos vermelhos.', 'ouve-se um choro digital distante.'],
            items: ['Disquete Raro', 'Chave de Criptografia', 'Peda√ßo de RAM', 'Manual de 1998', 'Bateria Velha'],
            directions: ['norte', 'sul', 'leste', 'oeste']
        };

        const asciiSkull = 
        "      _______\n" +
        "    .'_/_|_\\_'.\n" +
        "    \\\\`\\\\  |  /`/\n" +
        "     `\\\\  |  /`\n" +
        "       `\\\\|/`\n" +
        "         `\n" +
        "        ERROR 404: SOUL NOT FOUND";

        // --- GAME STATE ---
        let player = {
            x: 0,
            y: 0,
            inventory: [],
            visited: {}, // Map storage: "0,0": { desc: "...", item: "..." }
            health: 100
        };

        let isPuzzleActive = false;
        let isEncounterActive = false; // New state for AI interruption

        // --- CORE LOGIC ---
        
        const generateRoom = (x, y) => {
            const key = `${x},${y}`;
            if (player.visited[key]) return player.visited[key];

            // Special start room
            if (x === 0 && y === 0) {
                const room = {
                    desc: "Ponto de Inser√ß√£o. Uma mensagem pisca na tela: 'OBJETIVO: ENCONTRE O N√ì DE SEGURAN√áA PARA ESCAPAR'.",
                    item: "Lanterna de Debug", // Gift item to teach mechanics
                    isFirewall: false
                };
                player.visited[key] = room;
                return room;
            }

            // Random Generation
            // Increase firewall chance as you go further
            const dist = Math.abs(x) + Math.abs(y);
            let firewallChance = 0;
            if (dist > 2) firewallChance = 15;
            if (dist > 5) firewallChance = 30;

            const isFirewall = chance(firewallChance);
            
            let desc = "";
            if (isFirewall) {
                desc = "O ar fica denso. Voc√™ encontrou um N√ì DE SEGURAN√áA MESTRE. A sa√≠da est√° aqui.";
            } else {
                desc = `Um ${rng(worldData.nouns)} ${rng(worldData.adjectives)}. O local ${rng(worldData.details)}`;
            }

            // High loot chance early game to hook player
            let itemChance = 40;
            if (dist < 3) itemChance = 70; 

            const room = {
                desc: desc,
                item: (!isFirewall && chance(itemChance)) ? rng(worldData.items) : null,
                isFirewall: isFirewall
            };

            player.visited[key] = room;
            return room;
        };

        const look = () => {
            const room = generateRoom(player.x, player.y);
            print(`[ SETOR ${player.x},${player.y} ]`, "prompt");
            print(room.desc);
            
            if (room.isFirewall) {
                printHTML(`<pre class="ascii-art">${asciiSkull}</pre>`);
                print("‚ö†Ô∏è  ALERTA CR√çTICO: FIREWALL DETECTADO ‚ö†Ô∏è", "glitch");
                print("Para prosseguir, o sistema exige autentica√ß√£o biom√©trica dupla.", "");
                print("Digite *hackear* para tentar quebrar a seguran√ßa.", "");
            } else if (room.item) {
                print(`Voc√™ v√™ um item no ch√£o: *${room.item}*`);
            } else {
                print("N√£o h√° nada √∫til aqui.");
            }

            // Exits and Clues
            print("Sa√≠das poss√≠veis: norte, sul, leste, oeste.", "", 0);
            
            // Generate dynamic clues about neighbors
            const neighbors = [
                { dir: 'norte', x: player.x, y: player.y + 1 },
                { dir: 'sul', x: player.x, y: player.y - 1 },
                { dir: 'leste', x: player.x + 1, y: player.y },
                { dir: 'oeste', x: player.x - 1, y: player.y }
            ];
            
            // Simple peek logic (simulated)
            if (chance(40)) {
                const clueDir = rng(neighbors).dir;
                const clueText = rng([
                    `Um zumbido el√©trico vem do ${clueDir}.`,
                    `Voc√™ sente um vento frio vindo do ${clueDir}.`,
                    `O cheiro de oz√¥nio √© mais forte ao ${clueDir}.`
                ]);
                print(`DICA: ${clueText}`, "glitch");
            }
        };

        const triggerAIEncounter = () => {
            isEncounterActive = true;
            printHTML("<br><br>");
            print("üõë SISTEMA PAUSADO üõë", "glitch");
            print("Uma voz gutural invade seus fones:", "prompt");
            print("'QUEM √â VOC√ä QUE OUSA CAMINHAR NOS MEUS DADOS?'", "glitch");
            print("[1] Sou apenas um observador.", "");
            print("[2] Sou o Admin que veio te desligar.", "");
            print("Responda 1 ou 2...", "");
        };

        const resolveAIEncounter = (choice) => {
            if (choice === '1') {
                print("'Mentira. Observadores n√£o t√™m pulso.'", "glitch");
                print("O sistema tenta te fritar, mas voc√™ escapa por pouco.", "");
                isEncounterActive = false;
                look();
            } else if (choice === '2') {
                print("'ADMIN?! Hahahaha...'", "glitch");
                print("ACESSO NEGADO. PROTOCOLO DE EXTERM√çNIO INICIADO.", "glitch");
                isEncounterActive = false;
                startPuzzle(true); // Force SOS immediately
            } else {
                print("Resposta inv√°lida. O sil√™ncio √© uma confiss√£o.", "");
                startPuzzle(true);
            }
        };

        const move = (dir) => {
            if (isPuzzleActive) {
                print("Voc√™ n√£o pode sair. O Firewall te prendeu.", "glitch");
                return;
            }
            if (isEncounterActive) {
                print("VOC√ä N√ÉO PODE FUGIR DA PERGUNTA.", "glitch");
                return;
            }

            if (dir === 'norte') player.y++;
            if (dir === 'sul') player.y--;
            if (dir === 'leste') player.x++;
            if (dir === 'oeste') player.x--;
            
            // Random AI Encounter (15% chance on move)
            if (chance(15) && (Math.abs(player.x) + Math.abs(player.y) > 1)) {
                triggerAIEncounter();
                return; // Stop movement flow to handle encounter
            }

            // Flavor text
            if (chance(20)) {
                const flavors = [
                    "Voc√™ ouve passos met√°licos atr√°s de voc√™.",
                    "O ch√£o treme levemente.",
                    "Glitches visuais distorcem sua vis√£o por um segundo."
                ];
                print(rng(flavors), "glitch", 0);
            }

            look();
        };

        const take = () => {
            const room = generateRoom(player.x, player.y);
            if (room.item) {
                print(`Voc√™ pegou: ${room.item}`);
                player.inventory.push(room.item);
                room.item = null; 
            } else {
                print("Nada para pegar aqui.");
            }
        };

        const useItem = (itemName) => {
            // Simple fuzzy match
            const item = player.inventory.find(i => i.toLowerCase().includes(itemName));
            
            if (!item) {
                print("Voc√™ n√£o tem esse item.");
                return;
            }

            if (item.includes("Lanterna")) {
                print("Voc√™ acende a lanterna. Paredes revelam c√≥digos bin√°rios escondidos: 01001000 01000101 01001100 01010000 (HELP).", "glitch");
            } else if (item.includes("Manual")) {
                print("Voc√™ l√™ o manual: 'Para resetar o Firewall Mestre, a senha geralmente √© o nome do C√£o de Hades'. Interessante.", "");
            } else if (item.includes("RAM") || item.includes("Disquete")) {
                print("Voc√™ insere no seu deck. Dados corrompidos. In√∫til.", "");
            } else {
                print("Nada acontece.");
            }
        };

        const showInv = () => {
            if (player.inventory.length === 0) {
                print("Invent√°rio vazio.");
            } else {
                print("Invent√°rio: " + player.inventory.join(', '));
            }
        };

        const startPuzzle = (force = false) => {
            const room = generateRoom(player.x, player.y);
            
            if (!force && !room.isFirewall) {
                print("N√£o h√° nada para hackear aqui.");
                return;
            }

            isPuzzleActive = true;
            inputArea.style.display = 'none';
            
            if (force) {
                print("O SISTEMA TE ENCURRALOU.", "glitch");
            } else {
                print("INICIANDO QUEBRA DE FOR√áA BRUTA...", "glitch");
            }
            
            setTimeout(() => {
                print("ERRO CR√çTICO. SUA ALMA EST√Å SENDO DRENADA.", "glitch");
                print("Voc√™ precisa de um humano externo para sobreviver.", "");
                
                setTimeout(() => {
                        printHTML(`
                            <br>
                            ‚ö†Ô∏è <strong>PROTOCOLO S.O.S</strong> ‚ö†Ô∏è<br>
                            Sua √∫nica chance √© um humano real.<br><br>
                            <a href="https://wa.me/?text=SOS%20Estou%20preso%20no%20KERNEL%20PANIC%20(Setor%20${player.x},${player.y}).%20A%20IA%20vai%20me%20matar.%20Responda%20rapido:%20Qual%20e%20o%20nome%20do%20animal%20que%20guarda%20o%20inferno%20(3%20cabecas)?%20Jogue%20tambem:%20https://thekernelpanic.com" target="_blank" class="btn-hack" onclick="enableInput()">[ PEDIR AJUDA NO WHATSAPP ]</a>
                        `);
                }, 1500);
            }, 1500);
        };

        // --- INPUT HANDLING ---
        
        window.enableInput = () => {
            setTimeout(() => {
                inputArea.style.display = 'flex';
                input.focus();
                print("Aguardando chave externa...", "");
            }, 3000);
        };

        const processCommand = (raw) => {
            const cmd = raw.trim().toLowerCase();
            if (!cmd) return;

            if (isPuzzleActive) {
                 if (cmd === 'cerbero' || cmd === 'c√©rbero' || cmd === 'cerberus') {
                    print("ACESSO CONCEDIDO.", "glitch");
                    print("Voc√™ sobreviveu... por enquanto.", "");
                    isPuzzleActive = false;
                    if (player.visited[`${player.x},${player.y}`]) {
                        player.visited[`${player.x},${player.y}`].isFirewall = false;
                    }
                    look();
                 } else {
                    print("SENHA INCORRETA. Tente novamente.", "glitch");
                 }
                 return;
            }

            if (isEncounterActive) {
                if (['1', '2'].includes(cmd)) {
                    resolveAIEncounter(cmd);
                } else {
                    print("Responda [1] ou [2].", "glitch");
                }
                return;
            }

            if (cmd === 'start') {
                print("Reiniciando sistema...", "glitch");
                player.x = 0; player.y = 0; player.inventory = []; player.visited = {};
                isEncounterActive = false; isPuzzleActive = false;
                setTimeout(look, 1000);
                return;
            }

            if (['norte', 'n', 'sul', 's', 'leste', 'l', 'oeste', 'o'].includes(cmd)) {
                let dir = cmd;
                if (cmd === 'n') dir = 'norte';
                if (cmd === 's') dir = 'sul';
                if (cmd === 'l') dir = 'leste';
                if (cmd === 'o') dir = 'oeste';
                move(dir);
            } 
            else if (cmd === 'olhar' || cmd === 'ver') look();
            else if (cmd.startsWith('pegar')) take();
            else if (cmd.startsWith('usar ')) useItem(cmd.replace('usar ', ''));
            else if (cmd.startsWith('ler ')) useItem(cmd.replace('ler ', '')); // Alias for read
            else if (cmd === 'inv' || cmd === 'i') showInv();
            else if (cmd === 'hackear' || cmd === 'hack') startPuzzle();
            else if (cmd === 'ajuda') print("Comandos: norte, sul, leste, oeste, pegar, usar [item], inv");
            else print("Comando desconhecido.");
        };

        // --- INIT ---
        print("THE KERNEL PANIC v1.0", "glitch");
        print("Digite *start* para conectar.", "");

        // Fullscreen Logic
        const goFullscreen = () => {
            if (!document.fullscreenElement && document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(err => {});
            }
        };
        document.body.addEventListener('click', goFullscreen);

        input.addEventListener('keydown', (e) => {
            goFullscreen();
            if (e.key === 'Enter') {
                print(`> ${input.value}`);
                processCommand(input.value);
                input.value = '';
            }
        });
    </script>
</body>
</html>